import React, { useEffect } from "react";
import { useNavigate, useParams } from "react-router-dom";
import type { SubmitHandler } from "react-hook-form";
import { useForm } from "react-hook-form";
import toast from "react-hot-toast";
import { format } from "date-fns";
import SEO from "../../components/common/SEO";
import api from "../../services/api";

interface GalleryFormData {
  title: string;
  description: string;
  category: string;
  images: FileList;
  eventDate: string;
}

const GalleryEditor: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const isEditing = Boolean(id);
  const {
    register,
    handleSubmit,
    setValue,
    formState: { errors, isSubmitting },
  } = useForm<GalleryFormData>();
  const navigate = useNavigate();

  useEffect(() => {
    if (isEditing && id) {
      const fetchItem = async () => {
        try {
          const { data } = await api.get(`/api/gallery/${id}`);
          setValue("title", data.title);
          setValue("description", data.description);
          setValue("category", data.category);
          if (data.eventDate) {
            setValue(
              "eventDate",
              format(new Date(data.eventDate), "yyyy-MM-dd")
            );
          }
        } catch (error) {
          toast.error("Failed to load gallery item.");
          navigate("/admin/gallery");
        }
      };
      fetchItem();
    }
  }, [id, isEditing, setValue, navigate]);

  const onSubmit: SubmitHandler<GalleryFormData> = async (data) => {
    const formData = new FormData();
    formData.append("title", data.title);
    formData.append("description", data.description);
    formData.append("category", data.category);
    formData.append("eventDate", data.eventDate);

    if (data.images && data.images.length > 0) {
      Array.from(data.images).forEach((file) =>
        formData.append("images", file)
      );
    }

    const toastId = toast.loading(
      isEditing ? "Updating item..." : "Creating item..."
    );
    try {
      if (isEditing) {
        await api.put(`/api/gallery/${id}`, formData);
      } else {
        await api.post("/api/gallery", formData);
      }
      toast.success(`Gallery item ${isEditing ? "updated" : "created"}!`, {
        id: toastId,
      });
      navigate("/admin/gallery");
    } catch (error: any) {
      const errorMessage =
        error.response?.data?.message || "Operation failed. Please try again.";
      toast.error(errorMessage, { id: toastId });
      console.error(error);
    }
  };

  const inputStyles =
    "mt-1 block w-full rounded-md px-4 py-2.5 border border-gray-300 shadow-sm focus:border-brand-sky-blue focus:ring-1 focus:ring-brand-sky-blue";

  return (
    <div className="max-w-4xl mx-auto bg-white p-8 rounded-lg shadow-xl">
      <SEO
        title={isEditing ? "Edit Gallery Item" : "Create Gallery Item"}
        noIndex={true}
      />
      <h1 className="font-display text-3xl font-bold mb-8">
        {isEditing ? "Edit" : "Create"} Gallery Item
      </h1>
      <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
        <div>
          <label
            htmlFor="title"
            className="block text-sm font-medium text-gray-700"
          >
            Title
          </label>
          <input
            id="title"
            {...register("title", { required: "Title is required" })}
            className={inputStyles}
          />
          {errors.title && (
            <p className="text-red-500 text-xs mt-1">{errors.title.message}</p>
          )}
        </div>
        <div>
          <label
            htmlFor="description"
            className="block text-sm font-medium text-gray-700"
          >
            Description
          </label>
          <textarea
            id="description"
            rows={6}
            {...register("description", {
              required: "Description is required",
            })}
            className={inputStyles}
          />
          {errors.description && (
            <p className="text-red-500 text-xs mt-1">
              {errors.description.message}
            </p>
          )}
        </div>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div>
            <label
              htmlFor="category"
              className="block text-sm font-medium text-gray-700"
            >
              Category
            </label>
            <select
              id="category"
              {...register("category", { required: "Category is required" })}
              className={inputStyles}
            >
              <option value="">Select a category...</option>
              <option value="Partnerships">Partnerships</option>
              <option value="Education">Education</option>
              <option value="Support">Support</option>
              <option value="Skills Training">Skills Training</option>
            </select>
            {errors.category && (
              <p className="text-red-500 text-xs mt-1">
                {errors.category.message}
              </p>
            )}
          </div>
          <div>
            <label
              htmlFor="eventDate"
              className="block text-sm font-medium text-gray-700"
            >
              Date of Event
            </label>
            <input
              type="date"
              id="eventDate"
              {...register("eventDate", { required: "Date is required" })}
              className={inputStyles}
            />
            {errors.eventDate && (
              <p className="text-red-500 text-xs mt-1">
                {errors.eventDate.message}
              </p>
            )}
          </div>
        </div>
        <div>
          <label
            htmlFor="images"
            className="block text-sm font-medium text-gray-700"
          >
            Images (select one or multiple)
          </label>
          <input
            type="file"
            multiple
            id="images"
            {...register("images", { required: !isEditing })}
            className="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-brand-sky-blue/10 file:text-brand-sky-blue hover:file:bg-brand-sky-blue/20"
          />
          {errors.images && (
            <p className="text-red-500 text-xs mt-1">{errors.images.message}</p>
          )}
          {isEditing && (
            <p className="text-xs text-gray-500 mt-1">
              Uploading new images will replace all existing ones for this item.
            </p>
          )}
        </div>
        <div className="flex justify-end gap-4 border-t pt-6">
          <button
            type="button"
            onClick={() => navigate("/admin/gallery")}
            className="bg-gray-200 text-gray-700 font-bold py-2.5 px-6 rounded-lg transition-colors hover:bg-gray-300"
          >
            Cancel
          </button>
          <button
            type="submit"
            disabled={isSubmitting}
            className="bg-brand-dark-blue text-white font-bold py-2.5 px-6 rounded-lg disabled:opacity-50"
          >
            {isSubmitting
              ? "Saving..."
              : isEditing
              ? "Update Item"
              : "Create Item"}
          </button>
        </div>
      </form>
    </div>
  );
};

export default GalleryEditor;



import React, { useEffect } from "react";
import { useNavigate, useParams } from "react-router-dom";
import type { SubmitHandler } from "react-hook-form";
import { useForm } from "react-hook-form";
import toast from "react-hot-toast";
import SEO from "../../components/common/SEO";
import api from "../../services/api";

interface PublicationFormData {
  title: string;
  description: string;
  link: string;
  publicationDate: string;
  image: FileList;
}

const PublicationEditor: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const isEditing = Boolean(id);
  const {
    register,
    handleSubmit,
    setValue,
    formState: { errors, isSubmitting },
  } = useForm<PublicationFormData>();
  const navigate = useNavigate();

  // Fetch existing data for editing
  useEffect(() => {
    if (isEditing && id) {
      const fetchPublication = async () => {
        try {
          const { data } = await api.get(`/api/publications/${id}`);
          setValue("title", data.title);
          setValue("description", data.description);
          setValue("link", data.link);
          // Format date correctly for the date input field (YYYY-MM-DD)
          setValue(
            "publicationDate",
            new Date(data.publicationDate).toISOString().split("T")[0]
          );
        } catch (error) {
          toast.error("Failed to load publication data.");
          navigate("/admin/publications");
        }
      };
      fetchPublication();
    }
  }, [id, isEditing, setValue, navigate]);

  const onSubmit: SubmitHandler<PublicationFormData> = async (data) => {
    const formData = new FormData();
    formData.append("title", data.title);
    formData.append("description", data.description);
    formData.append("link", data.link);
    formData.append("publicationDate", data.publicationDate);

    // Only append the image if one was selected
    if (data.image && data.image.length > 0) {
      formData.append("image", data.image[0]);
    }

    const toastId = toast.loading(
      isEditing ? "Updating publication..." : "Creating publication..."
    );
    try {
      if (isEditing) {
        await api.put(`/api/publications/${id}`, formData);
        toast.success("Publication updated!", { id: toastId });
      } else {
        await api.post("/api/publications", formData);
        toast.success("Publication created!", { id: toastId });
      }
      navigate("/admin/publications");
    } catch (error: any) {
      // Display the specific error message from the backend
      const message =
        error.response?.data?.message || "Operation failed. Please try again.";
      toast.error(message, { id: toastId });
    }
  };

  return (
    <>
      <SEO
        title={isEditing ? "Edit Publication" : "Create Publication"}
        noIndex={true}
      />
      <div className="max-w-4xl mx-auto bg-white p-8 rounded-lg shadow">
        <h1 className="text-2xl font-bold mb-6">
          {isEditing ? "Edit" : "Create"} Publication
        </h1>
        <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
          <div>
            <label
              htmlFor="title"
              className="block text-sm font-medium text-gray-700"
            >
              Title
            </label>
            <input
              id="title"
              {...register("title", { required: "Title is required" })}
              className="mt-1 block w-full rounded-lg border-gray-300 shadow-sm focus:border-brand-sky-blue focus:ring-1 focus:ring-brand-sky-blue"
            />
            {errors.title && (
              <p className="text-red-500 text-xs mt-1">
                {errors.title.message}
              </p>
            )}
          </div>
          <div>
            <label
              htmlFor="description"
              className="block text-sm font-medium text-gray-700"
            >
              Description
            </label>
            <textarea
              id="description"
              rows={4}
              {...register("description", {
                required: "Description is required",
              })}
              className="mt-1 block w-full rounded-lg border-gray-300 shadow-sm focus:border-brand-sky-blue focus:ring-1 focus:ring-brand-sky-blue"
            />
            {errors.description && (
              <p className="text-red-500 text-xs mt-1">
                {errors.description.message}
              </p>
            )}
          </div>
          <div>
            <label
              htmlFor="link"
              className="block text-sm font-medium text-gray-700"
            >
              Publication Link (URL)
            </label>
            <input
              type="url"
              id="link"
              {...register("link", { required: "A valid URL is required" })}
              className="mt-1 block w-full rounded-lg border-gray-300 shadow-sm focus:border-brand-sky-blue focus:ring-1 focus:ring-brand-sky-blue"
            />
            {errors.link && (
              <p className="text-red-500 text-xs mt-1">{errors.link.message}</p>
            )}
          </div>
          <div>
            <label
              htmlFor="publicationDate"
              className="block text-sm font-medium text-gray-700"
            >
              Publication Date
            </label>
            <input
              type="date"
              id="publicationDate"
              {...register("publicationDate", { required: "Date is required" })}
              className="mt-1 block w-full rounded-lg border-gray-300 shadow-sm focus:border-brand-sky-blue focus:ring-1 focus:ring-brand-sky-blue"
            />
            {errors.publicationDate && (
              <p className="text-red-500 text-xs mt-1">
                {errors.publicationDate.message}
              </p>
            )}
          </div>
          <div>
            <label
              htmlFor="image"
              className="block text-sm font-medium text-gray-700"
            >
              Image (Screenshot)
            </label>
            <input
              type="file"
              id="image"
              {...register("image", { required: !isEditing })}
              className="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-brand-sky-blue/10 file:text-brand-sky-blue hover:file:bg-brand-sky-blue/20"
            />
            {errors.image && (
              <p className="text-red-500 text-xs mt-1">
                {errors.image.message}
              </p>
            )}
          </div>
          <div className="flex justify-end gap-4">
            <button
              type="button"
              onClick={() => navigate("/admin/publications")}
              className="bg-gray-200 text-gray-700 font-bold py-2 px-4 rounded-lg"
            >
              Cancel
            </button>
            <button
              type="submit"
              disabled={isSubmitting}
              className="bg-brand-dark-blue text-white font-bold py-2.5 px-6 rounded-lg disabled:opacity-50"
            >
              {isSubmitting
                ? "Saving..."
                : isEditing
                ? "Update Publication"
                : "Create Publication"}
            </button>
          </div>
        </form>
      </div>
    </>
  );
};

export default PublicationEditor;


import { useEffect, useCallback } from "react";
import { useNavigate, useParams } from "react-router-dom";
import { useForm } from "react-hook-form";
import type { SubmitHandler } from "react-hook-form";
import api from "../../services/api";
import toast from "react-hot-toast";

import { useEditor, EditorContent } from "@tiptap/react";
import StarterKit from "@tiptap/starter-kit";
import Underline from "@tiptap/extension-underline";
import Link from "@tiptap/extension-link";

import {
  BoldIcon,
  ItalicIcon,
  UnderlineIcon,
  LinkIcon,
  H2Icon,
  H3Icon,
  ListIcon,
  QuoteIcon,
} from "../../components/common/admin/AdminIcons";
import SEO from "../../components/common/SEO";

const MenuBar = ({ editor }: { editor: any | null }) => {
  if (!editor) return null;

  const buttonClass = (isActive: boolean) =>
    `p-2 rounded-md transition-colors ${
      isActive
        ? "bg-brand-dark-gray text-white"
        : "bg-gray-200 text-gray-700 hover:bg-gray-300"
    }`;

  const setLink = useCallback(() => {
    const previousUrl = editor.getAttributes("link").href;
    const url = window.prompt("URL", previousUrl);
    if (url === null) return;
    if (url === "") {
      editor.chain().focus().extendMarkRange("link").unsetLink().run();
      return;
    }
    editor
      .chain()
      .focus()
      .extendMarkRange("link")
      .setLink({ href: url, target: "_blank" })
      .run();
  }, [editor]);

  return (
    <div className="flex flex-wrap items-center gap-2 p-2 border border-b-0 border-gray-300 rounded-t-lg bg-gray-50">
      <SEO title={editor ? "Edit Post" : "Create Post"} noIndex={true} />
      <button
        type="button"
        onClick={() => editor.chain().focus().toggleBold().run()}
        className={buttonClass(editor.isActive("bold"))}
        title="Bold"
      >
        <BoldIcon />
      </button>
      <button
        type="button"
        onClick={() => editor.chain().focus().toggleItalic().run()}
        className={buttonClass(editor.isActive("italic"))}
        title="Italic"
      >
        <ItalicIcon />
      </button>
      <button
        type="button"
        onClick={() => editor.chain().focus().toggleUnderline().run()}
        className={buttonClass(editor.isActive("underline"))}
        title="Underline"
      >
        <UnderlineIcon />
      </button>
      <button
        type="button"
        onClick={setLink}
        className={buttonClass(editor.isActive("link"))}
        title="Add Link"
      >
        <LinkIcon />
      </button>
      <div className="w-px h-6 bg-gray-300"></div>
      <button
        type="button"
        onClick={() => editor.chain().focus().toggleHeading({ level: 2 }).run()}
        className={buttonClass(editor.isActive("heading", { level: 2 }))}
        title="Heading 2"
      >
        <H2Icon />
      </button>
      <button
        type="button"
        onClick={() => editor.chain().focus().toggleHeading({ level: 3 }).run()}
        className={buttonClass(editor.isActive("heading", { level: 3 }))}
        title="Heading 3"
      >
        <H3Icon />
      </button>
      <div className="w-px h-6 bg-gray-300"></div>
      <button
        type="button"
        onClick={() => editor.chain().focus().toggleBulletList().run()}
        className={buttonClass(editor.isActive("bulletList"))}
        title="Bullet List"
      >
        <ListIcon />
      </button>
      <button
        type="button"
        onClick={() => editor.chain().focus().toggleBlockquote().run()}
        className={buttonClass(editor.isActive("blockquote"))}
        title="Blockquote"
      >
        <QuoteIcon />
      </button>
    </div>
  );
};

interface BlogFormData {
  title: string;
  excerpt: string;
  authorName: string;
  authorLinkedin: string;
  content: string;
  image: FileList;
}

const BlogEditor = () => {
  const { id } = useParams<{ id: string }>();
  const isEditing = Boolean(id);
  const navigate = useNavigate();
  const {
    register,
    handleSubmit,
    setValue,
    formState: { errors, isSubmitting },
  } = useForm<BlogFormData>();

  const editor = useEditor({
    extensions: [
      StarterKit,
      Underline,
      Link.configure({ openOnClick: false, autolink: true }),
    ],
    content: "",
    onUpdate: ({ editor }) => {
      setValue("content", editor.getHTML(), { shouldValidate: true });
    },
    editorProps: {
      attributes: {
        class:
          "prose max-w-none p-4 border border-gray-300 rounded-b-lg min-h-[400px] focus:outline-none focus:ring-2 focus:ring-brand-sky-blue",
      },
    },
  });

  useEffect(() => {
    if (isEditing && editor) {
      const fetchBlog = async () => {
        try {
          const { data } = await api.get(`/api/blogs/${id}`);
          setValue("title", data.title);
          setValue("excerpt", data.excerpt);
          setValue("authorName", data.authorName);
          setValue("authorLinkedin", data.authorLinkedin);
          editor.commands.setContent(data.content);
        } catch (error) {
          toast.error("Failed to load blog post.");
        }
      };
      fetchBlog();
    }
  }, [id, isEditing, setValue, editor]);

  const onSubmit: SubmitHandler<BlogFormData> = async (data) => {
    const formData = new FormData();
    formData.append("title", data.title);
    formData.append("excerpt", data.excerpt);
    formData.append("authorName", data.authorName);
    formData.append("authorLinkedin", data.authorLinkedin);
    formData.append("content", data.content);
    if (data.image && data.image.length > 0) {
      formData.append("image", data.image[0]);
    }

    const toastId = toast.loading(
      isEditing ? "Updating post..." : "Creating post..."
    );
    try {
      if (isEditing) {
        await api.put(`/api/blogs/${id}`, formData);
      } else {
        await api.post("/api/blogs", formData);
      }
      toast.success(`Post ${isEditing ? "updated" : "created"} successfully!`, {
        id: toastId,
      });
      navigate("/admin/blogs");
    } catch (error: any) {
      toast.error(error.response?.data?.message || "Operation failed.", {
        id: toastId,
      });
    }
  };

  const inputStyles =
    "mt-1 block w-full rounded-md border border-gray-300 shadow-sm focus:border-brand-sky-blue focus:ring-brand-sky-blue";

  return (
    <div className="max-w-4xl mx-auto bg-white p-8 rounded-lg shadow-xl">
      <h1 className="font-display text-3xl font-bold mb-8">
        {isEditing ? "Edit" : "Create"} Post
      </h1>
      <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
        <div>
          <label className="font-medium text-gray-700">Title</label>
          <input
            {...register("title", { required: "Title is required" })}
            className={inputStyles}
          />
          {errors.title && (
            <p className="text-red-500 text-xs mt-1">{errors.title.message}</p>
          )}
        </div>
        <div>
          <label className="font-medium text-gray-700">
            Excerpt (A short summary for the blog page)
          </label>
          <textarea
            rows={3}
            {...register("excerpt", { required: "Excerpt is required" })}
            className={inputStyles}
          />
          {errors.excerpt && (
            <p className="text-red-500 text-xs mt-1">
              {errors.excerpt.message}
            </p>
          )}
        </div>
        <div className="grid grid-cols-2 gap-4">
          <div>
            <label className="font-medium text-gray-700">Author Name</label>
            <input
              {...register("authorName", {
                required: "Author name is required",
              })}
              className={inputStyles}
            />
            {errors.authorName && (
              <p className="text-red-500 text-xs mt-1">
                {errors.authorName.message}
              </p>
            )}
          </div>
          <div>
            <label className="font-medium text-gray-700">
              Author's LinkedIn URL (Optional)
            </label>
            <input {...register("authorLinkedin")} className={inputStyles} />
          </div>
        </div>
        <div>
          <label className="font-medium text-gray-700">Feature Image</label>
          <input
            type="file"
            {...register("image", { required: !isEditing })}
            className="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-brand-sky-blue/10 file:text-brand-sky-blue hover:file:bg-brand-sky-blue/20"
          />
          {errors.image && (
            <p className="text-red-500 text-xs mt-1">{errors.image.message}</p>
          )}
        </div>
        <div>
          <label className="font-medium text-gray-700">Content</label>
          <MenuBar editor={editor} />
          <EditorContent editor={editor} />
          <input
            type="hidden"
            {...register("content", {
              required: "Content cannot be empty.",
              minLength: { value: 15, message: "Content is too short." },
            })}
          />
          {errors.content && (
            <p className="text-red-500 text-xs mt-1">
              {errors.content.message}
            </p>
          )}
        </div>
        <div className="flex justify-end gap-4 border-t pt-6">
          <button
            type="button"
            onClick={() => navigate("/admin/blogs")}
            className="bg-gray-200 text-gray-700 font-bold py-2.5 px-6 rounded-lg transition-colors hover:bg-gray-300"
          >
            Cancel
          </button>
          <button
            type="submit"
            disabled={isSubmitting}
            className="bg-brand-dark-blue text-white font-bold py-2.5 px-6 rounded-lg disabled:opacity-50"
          >
            {isSubmitting
              ? "Saving..."
              : isEditing
              ? "Update Post"
              : "Create Post"}
          </button>
        </div>
      </form>
    </div>
  );
};

export default BlogEditor;

import axios from 'axios';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL;

const api = axios.create({
  baseURL: API_BASE_URL,
  headers: { 'Content-Type': 'application/json' },
});

api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('adminToken');
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`;
    }
    if (config.data instanceof FormData) {
      delete config.headers['Content-Type'];
    }
    return config;
  },
  (error) => Promise.reject(error)
);

export default api;


import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// https://vitejs.dev/config/
export default defineConfig({
  base: './',
  plugins: [react()],
  // --- REMOVE THE ENTIRE server.proxy SECTION ---
  server: {
    port: 5173,
  },
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
})



const Blog = require('../models/Blog');

exports.getBlogs = async (req, res) => {
  try {
    const blogs = await Blog.find({}).sort({ createdAt: -1 });
    res.json(blogs);
  } catch (error) { res.status(500).json({ message: 'Server Error' }); }
};

// Get single blog by ID (Public)
exports.getBlogById = async (req, res) => {
  try {
    const blog = await Blog.findById(req.params.id);
    if (!blog) return res.status(404).json({ message: 'Blog post not found' });
    res.json(blog);
  } catch (error) { res.status(500).json({ message: 'Server Error' }); }
};

// --- CREATE a blog post (Robust Version) ---
exports.createBlog = async (req, res) => {
  try {
    const { title, content, excerpt, authorName, authorLinkedin } = req.body;
    if (!title || !content || !excerpt || !authorName) {
        return res.status(400).json({ message: 'Title, content, excerpt, and author name are required.' });
    }
    if (!req.file) {
        return res.status(400).json({ message: 'A feature image is required.' });
    }
    const newBlog = new Blog({ title, content, excerpt, authorName, authorLinkedin, imageUrl: req.file.path });
    const savedBlog = await newBlog.save();
    res.status(201).json(savedBlog);
  } catch (error) {
    console.error("Create Blog Error:", error);
    res.status(500).json({ message: 'Server Error: ' + error.message });
  }
};

// --- UPDATE a blog post (Robust Version) ---
exports.updateBlog = async (req, res) => {
  try {
    const { title, content, excerpt, authorName, authorLinkedin } = req.body;
    const blog = await Blog.findById(req.params.id);
    if (!blog) return res.status(404).json({ message: 'Blog post not found' });
    
    if(title) blog.title = title;
    if(content) blog.content = content;
    if(excerpt) blog.excerpt = excerpt;
    if(authorName) blog.authorName = authorName;
    if(authorLinkedin) blog.authorLinkedin = authorLinkedin;

    if (req.file) {
        blog.imageUrl = req.file.path;
    }

    const updatedBlog = await blog.save();
    res.json(updatedBlog);
  } catch (error) {
    console.error("Update Blog Error:", error);
    res.status(500).json({ message: 'Server Error' + error.message });
  }
};

// Delete a blog (Protected)
exports.deleteBlog = async (req, res) => {
  try {
    const blog = await Blog.findByIdAndDelete(req.params.id); // More efficient
    if (!blog) return res.status(404).json({ message: 'Blog post not found' });
    res.json({ message: 'Blog post removed' });
  } catch (error) { res.status(500).json({ message: 'Server Error' }); }
};


const Gallery = require('../models/Gallery'); // Ensure this path is correct

// --- CREATE a new gallery item (REVISED AND ROBUST) ---
exports.createGalleryItem = async (req, res) => {
  console.log('Received body:', req.body);
  console.log('Received files:', req.files);

  try {
    const { title, description, category, eventDate } = req.body;

    if (!title || !description || !category || !eventDate) {
      return res.status(400).json({ message: 'Missing required fields: title, description, category, and eventDate are all required.' });
    }

    if (!req.files || req.files.length === 0) {
      return res.status(400).json({ message: 'At least one image file must be uploaded.' });
    }

    const imageUrls = req.files.map(file => file.path);

    const newItem = new Gallery({
      title,
      description,
      category,
      eventDate,
      imageUrls
    });

    await newItem.save();
    res.status(201).json(newItem);
  } catch (error) {
    console.error("Error creating gallery item:", error);
    res.status(500).json({ message: 'Server Error: ' + error.message });
  }
};

// --- GET ALL GALLERY ITEMS (Unchanged, but included for completeness) ---
exports.getGalleryItems = async (req, res) => {
    try {
        const page = parseInt(req.query.page, 10) || 1;
        const limit = parseInt(req.query.limit, 10) || 9;
        const category = req.query.category;
        const search = req.query.search;
        
        const startIndex = (page - 1) * limit;
        let query = {};
        if (category && category.toLowerCase() !== 'all') {
            query.category = category;
        }
        if (search) {
            query.title = { $regex: search, $options: 'i' };
        }

        const items = await Gallery.find(query).sort({ eventDate: -1 }).limit(limit).skip(startIndex);
        const totalItems = await Gallery.countDocuments(query);

        res.status(200).json({
            images: items,
            hasMore: (startIndex + items.length) < totalItems,
            total: totalItems,
        });
    } catch (error) {
        console.error("Error fetching gallery items:", error);
        res.status(500).json({ message: 'Server Error' });
    }
};

// --- GET A SINGLE ITEM by ID (Unchanged) ---
exports.getGalleryItemById = async (req, res) => {
    try {
        const item = await Gallery.findById(req.params.id);
        if (!item) return res.status(404).json({ message: 'Item not found' });
        res.json(item);
    } catch (error) {
        res.status(500).json({ message: 'Server Error' });
    }
};

// --- UPDATE an item (Revised for robustness) ---
exports.updateGalleryItem = async (req, res) => {
    try {
        const { title, description, category, eventDate } = req.body;
        const item = await Gallery.findById(req.params.id);
        if (!item) return res.status(404).json({ message: 'Item not found' });

        if (title) item.title = title;
        if (description) item.description = description;
        if (category) item.category = category;
        if (eventDate) item.eventDate = eventDate;

        if (req.files && req.files.length > 0) {
            item.imageUrls = req.files.map(file => file.path);
        }

        const updatedItem = await item.save();
        res.json(updatedItem);
    } catch (error) {
        console.error("Error updating gallery item:", error);
        res.status(500).json({ message: 'Server Error: ' + error.message });
    }
};

// --- DELETE an item (Unchanged) ---
exports.deleteGalleryItem = async (req, res) => {
    try {
        const item = await Gallery.findById(req.params.id);
        if (!item) return res.status(404).json({ message: 'Item not found' });
        await item.deleteOne();
        res.json({ message: 'Gallery item deleted' });
    } catch (error) {
        res.status(500).json({ message: 'Server Error' });
    }
};


const Publication = require('../models/Publication');

/**
 * @desc    Get all publications, sorted newest first
 * @route   GET /api/publications
 * @access  Public
 */
exports.getPublications = async (req, res) => {
  try {
    const publications = await Publication.find({}).sort({ createdAt: -1 });
    res.status(200).json(publications);
  } catch (error) {
    console.error("Error fetching publications:", error);
    res.status(500).json({ message: 'Server Error' });
  }
};

/**
 * @desc    Get a single publication by its ID
 * @route   GET /api/publications/:id
 * @access  Public
 */
exports.getPublicationById = async (req, res) => {
  try {
    const publication = await Publication.findById(req.params.id);
    if (!publication) {
      return res.status(404).json({ message: 'Publication not found' });
    }
    res.status(200).json(publication);
  } catch (error) {
    console.error(`Error fetching publication with ID ${req.params.id}:`, error);
    res.status(500).json({ message: 'Server Error' });
  }
};

/**
 * @desc    Create a new publication
 * @route   POST /api/publications
 * @access  Private/Admin
 */
exports.createPublication = async (req, res) => {
  try {
    const { title, description, link, publicationDate } = req.body;
    
    if (!title) return res.status(400).json({ message: 'Title is a required field.' });
    if (!description) return res.status(400).json({ message: 'Description is a required field.' });
    if (!link) return res.status(400).json({ message: 'Publication link is a required field.' });
    if (!publicationDate) return res.status(400).json({ message: 'Publication date is a required field.' });
    if (!req.file) return res.status(400).json({ message: 'An image file is required.' });

    console.log('Received Body:', req.body);
    console.log('Received File:', req.file);

    const newPublication = new Publication({
      title,
      description,
      link,
      publicationDate: new Date(publicationDate),
      imageUrl: req.file.path
    });

    await newPublication.save();
    res.status(201).json(newPublication);
  } catch (error) {
    console.error("CREATE PUBLICATION FAILED:", error);
    res.status(500).json({ message: 'Server Error: ' + error.message });
  }
};
/**
 * @desc    Update an existing publication
 * @route   PUT /api/publications/:id
 * @access  Private/Admin
 */
exports.updatePublication = async (req, res) => {
  try {
    const { title, description, link } = req.body;
    const publication = await Publication.findById(req.params.id);

    if (!publication) {
      return res.status(404).json({ message: 'Publication not found' });
    }

    // Update fields from the form
    publication.title = title || publication.title;
    publication.description = description || publication.description;
    publication.link = link || publication.link;
    
    // If a new photo was uploaded, update its URL
    if (req.file) {
      // Note: This doesn't delete the old image from Cloudinary, which is a more advanced step.
      publication.imageUrl = req.file.path;
    }

    const updatedPublication = await publication.save();
    res.status(200).json(updatedPublication);
  } catch (error) {
    console.error(`Error updating publication with ID ${req.params.id}:`, error);
    res.status(500).json({ message: 'Server Error: ' + error.message });
  }
};

/**
 * @desc    Delete a publication
 * @route   DELETE /api/publications/:id
 * @access  Private/Admin
 */
exports.deletePublication = async (req, res) => {
  try {
    const publication = await Publication.findByIdAndDelete(req.params.id);

    if (!publication) {
      return res.status(404).json({ message: 'Publication not found' });
    }

    // Note: This also doesn't delete the image from Cloudinary.
    res.status(200).json({ message: 'Publication removed successfully' });
  } catch (error) {
    console.error(`Error deleting publication with ID ${req.params.id}:`, error);
    res.status(500).json({ message: 'Server Error' });
  }
};


const mongoose = require('mongoose');

const BlogSchema = new mongoose.Schema({
  title: { type: String, required: true },
  content: { type: String, required: true }, 
  excerpt: { type: String, required: true },
  imageUrl: { type: String, required: true },
  authorName: { type: String, required: true },
  authorLinkedin: { type: String },
}, { timestamps: true });

module.exports = mongoose.model('Blog', BlogSchema);


const mongoose = require('mongoose');

const GallerySchema = new mongoose.Schema({
  title: { 
    type: String, 
    required: [true, 'Title is required.'] 
  },
  description: { 
    type: String, 
    required: [true, 'Description is required.'] 
  },
  category: { 
    type: String, 
    required: [true, 'Category is required.'] 
  },
  imageUrls: [{ 
    type: String, 
    required: true 
  }],
  eventDate: {
    type: Date,
    required: [true, 'Event date is required.']
  },
}, { timestamps: true });

module.exports = mongoose.model('Gallery', GallerySchema);

const mongoose = require('mongoose');

const PublicationSchema = new mongoose.Schema({
  title: {
    type: String,
    required: true,
  },
  description: {
    type: String,
    required: true,
  },
  link: {
    type: String,
    required: true,
  },
  // This will store the secure URL from Cloudinary for the photo
  imageUrl: {
    type: String,
    required: true,
  },
}, {
  // This automatically adds `createdAt` and `updatedAt` fields
  timestamps: true 
});

module.exports = mongoose.model('Publication', PublicationSchema);


const express = require('express');
const router = express.Router();
const multer = require('multer');
const { storage } = require('../config/cloudinary'); // Use the same Cloudinary storage
const { protect } = require('../middleware/authMiddleware');
const { getBlogs, getBlogById, createBlog, updateBlog, deleteBlog } = require('../controllers/blogController');

const upload = multer({ storage });

router.route('/')
  .get(getBlogs)
  .post(protect, upload.single('image'), createBlog); 

router.route('/:id')
  .get(getBlogById)
  .put(protect, upload.single('image'), updateBlog)
  .delete(protect, deleteBlog);

module.exports = router;

const express = require('express');
const router = express.Router();
const multer = require('multer');
const { storage } = require('../config/cloudinary'); // Import our configured storage
const { protect } = require('../middleware/authMiddleware');

const upload = multer({ storage });

const {
    createGalleryItem,
    getGalleryItems,
    getGalleryItemById,
    updateGalleryItem,
    deleteGalleryItem
} = require('../controllers/galleryController');

router.route('/')
    .get(getGalleryItems)
    .post(protect, upload.array('images', 10), createGalleryItem);

router.route('/:id')
    .get(getGalleryItemById)
    .put(protect, upload.array('images', 10), updateGalleryItem)
    .delete(protect, deleteGalleryItem);

module.exports = router;


const express = require('express');
const router = express.Router();
const multer = require('multer');
const { storage } = require('../config/cloudinary');
const { protect } = require('../middleware/authMiddleware');
const {
  getPublications,
  getPublicationById,
  createPublication,
  updatePublication,
  deletePublication
} = require('../controllers/publicationController');

// Configure multer to use Cloudinary storage.
// It will expect a single file from a form field named 'image'.
const upload = multer({ storage });

// Route for getting all publications (public) and creating one (protected)
router.route('/')
  .get(getPublications)
  .post(protect, upload.single('image'), createPublication);

// Routes for a single publication: get, update, and delete (all protected except get)
router.route('/:id')
  .get(getPublicationById) // Useful for pre-filling the edit form
  .put(protect, upload.single('image'), updatePublication)
  .delete(protect, deletePublication);

module.exports = router;



